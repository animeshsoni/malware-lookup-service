from flask import Flask, jsonify, request
from flask_httpauth import HTTPBasicAuth
import sqlite3
import bcrypt


service = Flask(__name__)
auth = HTTPBasicAuth()

#Add default user and password. TODO: Hash password instead of storing in plain text.
#User list can be moved to a db if we have use case for multiple users.
#In a prod service, we should use token based auth. 
users = {
    #User and hashed password. Because this is a demo service, password is "someComplexPassword"
    "default": b'$2b$12$mix29YjcVnpv9JEPbrZloeS.yuo23HZwCTmmx50wevY8mvNOWzoVG'
}

@auth.verify_password
def verify_password(username, password):
    return username in users and bcrypt.checkpw(password.encode('utf8'), users.get(username))    

@auth.error_handler
def unauthorized():
    return jsonify({'error': 'Unauthorized'})

try:
    #Open a connection to DB. (Creates one if it doesn't exist)
    dbCon = sqlite3.connect("malwareList.db")
    dbCursor = dbCon.cursor()
    #Check if malwareUrls table exists
    dbResult = dbCursor.execute("SELECT name FROM sqlite_master WHERE name='malwareUrls'")
    if dbResult.fetchone() == None:
        #Create table if it doesn't exist
        dbCursor.execute("CREATE TABLE malwareUrls(url)")
        # Generate fake list of malwares to experiment with.
        for i in range(500):
            dbCursor.execute("INSERT INTO malwareUrls VALUES ('malware" + str(i) + "')")
            dbCon.commit()
    dbCursor.close()
except sqlite3.Error as error:
    print("'error': 'Error while connecting to database: " + str(error) + "'")
finally:
    if dbCon:
        dbCon.close()

# Home screen for the service. TODO: Add link to instructions or remove this function if not needed.
@service.route("/")
@auth.login_required
def home():
    return "Malware URL lookup service!"

# Function to provide information about URL after checking malware DB. 
@service.route('/v1/urlinfo/<resource_url_with_query_string>',methods=['GET'])
@auth.login_required
def isMalware(resource_url_with_query_string):
    #Assume safe by default, unless found in malware DB.
    retVal = jsonify({'response': 'safe'})
    try:
        dbCon = sqlite3.connect("malwareList.db")
        dbCursor = dbCon.cursor()
        dbResult = dbCursor.execute("SELECT name FROM sqlite_master WHERE name='malwareUrls'")
        if dbResult.fetchone() == None:
            #Table doesn't exist, something is wrong. TODO: Change this response if needed. Assuming safe for now.
            return retVal
        dbResult = dbCursor.execute("SELECT url FROM malwareUrls WHERE url='" + resource_url_with_query_string + "'")
        if dbResult.fetchone() != None:
            #Found in malware DB
            retVal = jsonify({'response': 'unsafe'})
        dbCursor.close()
    except sqlite3.Error as error:
        return jsonify({'error': 'Error while connecting to database: ' + str(error)})
    finally:
        if dbCon:
            dbCon.close()
    return retVal

#Function to add new URLs to malware DB.
@service.route('/v1/urlinfo',methods=['POST'])
def addMalware():
    if not 'url' in request.json:
        return jsonify({'error': 'No field \"url\" in message body'})
    url = request.json['url']
    try:
        dbCon = sqlite3.connect("malwareList.db")
        dbCursor = dbCon.cursor()
        dbResult = dbCursor.execute("SELECT name FROM sqlite_master WHERE name='malwareUrls'")
        if dbResult.fetchone() == None:
            #Create table if it doesn't exist
            dbCursor.execute("CREATE TABLE malwareUrls(url)")
        dbResult = dbCursor.execute("INSERT INTO malwareUrls VALUES ('" + url + "')")
        dbCon.commit()
        dbCursor.close()
    except sqlite3.Error as error:
        return jsonify({'error': 'Error while connecting to database: ' + str(error)})
    finally:
        if dbCon:
            dbCon.close()
    return jsonify({'response': 'success'})

# Start the service. Currently hosted on localhost:5000. TODO: Change the default and host it on web if required.
if __name__ == "__main__":
    service.run()